// code by jph
package ch.alpine.surich.net;

import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.util.List;

import ch.alpine.ascony.dis.ManifoldDisplay;
import ch.alpine.ascony.dis.ManifoldDisplays;
import ch.alpine.ascony.ref.AsconaParam;
import ch.alpine.ascony.ren.PointsRender;
import ch.alpine.ascony.win.ControlPointsDemo;
import ch.alpine.bridge.fig.DensityPlot;
import ch.alpine.bridge.fig.Show;
import ch.alpine.bridge.gfx.GeometricLayer;
import ch.alpine.bridge.ref.ann.FieldFuse;
import ch.alpine.bridge.ref.ann.FieldSelectionArray;
import ch.alpine.bridge.ref.ann.ReflectionMarker;
import ch.alpine.subare.net.NetChain;
import ch.alpine.subare.net.NetChains;
import ch.alpine.subare.net.NetTrain;
import ch.alpine.tensor.RealScalar;
import ch.alpine.tensor.Scalar;
import ch.alpine.tensor.Tensor;
import ch.alpine.tensor.Tensors;
import ch.alpine.tensor.alg.Dimensions;
import ch.alpine.tensor.img.ColorDataGradients;
import ch.alpine.tensor.img.ColorDataIndexed;
import ch.alpine.tensor.img.ColorDataLists;
import ch.alpine.tensor.opt.nd.CoordinateBoundingBox;
import ch.alpine.tensor.opt.nd.CoordinateBounds;
import ch.alpine.tensor.pdf.RandomSample;
import ch.alpine.tensor.pdf.RandomVariate;
import ch.alpine.tensor.pdf.d.DiscreteUniformDistribution;
import ch.alpine.tensor.qty.Quantity;

public class NetClassifyDemo extends ControlPointsDemo {
  @ReflectionMarker
  public static class Param0 extends AsconaParam {
    public Param0() {
      super(false);
      drawControlPoints = false;
    }

    @FieldSelectionArray({ "10", "20", "50" })
    public Integer size = 20;
    @FieldSelectionArray({ "2", "3", "4", "5" })
    public Integer labels = 3;
    @FieldFuse
    public transient Boolean shuffle = false;
    public ColorDataLists cdg = ColorDataLists._097;
  }

  @ReflectionMarker
  public static class Param2 {
    @FieldFuse
    public transient Boolean train = false;
  }

  private final Param0 param0;
  @SuppressWarnings("unused")
  private final Param2 param2;
  // ---
  Show show = new Show();
  protected Tensor vector;

  public NetClassifyDemo() {
    this(new Param0(), new Param2());
  }

  public NetClassifyDemo(Param0 param0, Param2 param2) {
    super(param0, param2);
    this.param0 = param0;
    this.param2 = param2;
    setManifoldDisplay(ManifoldDisplays.R2);
    fieldsEditor(0).addUniversalListener(this::shuffle);
    fieldsEditor(1).addUniversalListener(this::train);
    shuffle();
  }

  @Override
  public List<ManifoldDisplays> permitted_manifoldDisplays() {
    return ManifoldDisplays.R2_ONLY;
  }

  private void shuffle() {
    int n = param0.size;
    ManifoldDisplay manifoldDisplay = manifoldDisplay();
    Tensor tensor = Tensor.of(RandomSample.of(manifoldDisplay.randomSampleInterface(), n).stream() //
        .map(manifoldDisplay::point2xya));
    setControlPointsSe2(tensor);
    // assignment of random labels to points
    int k = param0.labels;
    vector = RandomVariate.of(DiscreteUniformDistribution.forArray(k), n);
    train();
  }

  private void train() {
    Tensor xdata = getGeodesicControlPoints();
    CoordinateBoundingBox cbb = CoordinateBounds.of(xdata);
    NetChain netChain = NetChains.argMaxMLP(2, 7, param0.labels);
    IO.println(Dimensions.of(xdata));
    NetTrain.of(netChain, xdata, vector, RealScalar.of(0.05), _ -> {
    }, Quantity.of(0.3, "s"), 3000, 10);
    show = new Show();
    show.add(DensityPlot.of((x, y) -> (Scalar) netChain.forward(Tensors.of(x, y)), cbb, ColorDataGradients.COPPER));
  }

  @Override // from RenderInterface
  public void render(GeometricLayer geometricLayer, Graphics2D graphics) {
    ManifoldDisplay manifoldDisplay = manifoldDisplay();
    Tensor xdata = getGeodesicControlPoints();
    CoordinateBoundingBox cbb = CoordinateBounds.of(xdata);
    Rectangle rectangle = geometricLayer.toRectangle(cbb);
    show.setAspectRatioDontCare();
    show.render(graphics, rectangle);
    // ---
    render(geometricLayer, graphics, manifoldDisplay, getGeodesicControlPoints(), vector, param0.cdg.cyclic());
  }

  static void render(GeometricLayer geometricLayer, Graphics2D graphics, ManifoldDisplay manifoldDisplay, Tensor sequence, Tensor vector,
      ColorDataIndexed colorDataIndexedT) {
    Tensor shape = manifoldDisplay.shape().multiply(RealScalar.of(1.0));
    int index = 0;
    ColorDataIndexed colorDataIndexedO = colorDataIndexedT.deriveWithAlpha(128);
    for (Tensor point : sequence) {
      int label = vector.Get(index).number().intValue();
      PointsRender pointsRender = new PointsRender( //
          colorDataIndexedO.getColor(label), //
          colorDataIndexedT.getColor(label));
      pointsRender.show(manifoldDisplay::matrixLift, shape, Tensors.of(point)).render(geometricLayer, graphics);
      ++index;
    }
  }

  static void main() {
    new NetClassifyDemo().runStandalone();
  }
}
